# はじめに
以前Flutterでアーキテクチャの考察を行った時に作った以下のリポジトリの`Jetpack Compose`版です。
https://github.com/hotdrop/my-flutter-consider-design-app
（上記リポジトリではProductFlavorの検証を行っていますが、このリポジトリではFlavor検証は不要なのでコーヒーverのみとします。）

GoogleのBasicCodeLabを写経してみましたがあまり納得がいかなかったので、上記のサンプルアプリを再現してみることにしました。
本当はDroidKaigi2023アプリのソースコードを読むのが一番良さそうなのですが、とりあえず手を動かしたかったのでまずはやりきって、その後DroidKaigi2023のソースコードを読んでみようと思います。

また、以下の記載内容は自分で調べた内容であり全て1次情報を確認したわけではなく`GPT-4o`に聞いただけで裏付けしていない情報も多いです。
そのため、間違いやベストプラクティスではない内容が多々あるかなと思います。

# 基本的な考え
Composeは`ComponentActivity`を継承したActivity上で実装し、ライフサイクルが異なる点や関数で画面およびコンポーネントを作っていく点など既存のAndroidViewとは全く違う世界になります。
Flutterと同様、AppBar（ComposeではTopBar）を使いたい場合は`Scaffold`をrootに置きます。ただ、必ずしもScaffoldをrootにする必要はありません。
## Composableアノテーションで定義した関数内の原理
FlutterのようにWidgetをreturnするわけでもなく、関数内に記載したコンポーネント（Composable定義されているもの）は全て描画処理対象になるという点が面白いです。
Composeは`@Composable`関数内でのコンポーザブルの呼び出しを「描画の命令」として捉えるようです。
Composeのフレームワークは関数内で呼び出された全てのコンポーザブルを「ツリー」として構築し、UIの再構築が必要な時にこのツリー全体を再計算します。 私はFlutterのように関数の最後でreturnするのに慣れていたため、この挙動は新鮮でした。
また、Flutterと違って影響を受けるコンポーネントしかリビルドされないようですが、LLMに聞いただけなので公式サイトを漁った方が良さそうです。
Flutterの場合は対象Widget全体がリビルド対象になってしまう（build関数が再実行される）のでここも新鮮でした。
## 画面遷移
`NavHost`と`NavController`で画面遷移を行います。ただ、`navController`をどうやって伝搬していくかが問題でした。Applicationから`navController`を引数で伝搬して使っていくのは無駄に引数が多くなって煩雑になると思います。
1画面1関数で実装するなら問題ありませんが、それは可読性が落ちるので通常はコンポーネントごとに`Composable`な関数に分割し、画面遷移処理を実装する関数にだけ渡せると良いかなと思います。
調べた範囲内ではどうやら以下の2パターンがありそうです。(他のパターンもあるかもしれません)
利点と欠点は`ChatGPT-4o`の回答です。

### 案1: CompositionLocalを使用する
`CompositionLocal`を使用して`NavController`をコンポジションツリー全体に渡す方法です。これにより、各コンポーネントは必要に応じて`NavController`にアクセスできます。
- 利点
  - コードがシンプルで`NavController`を各画面に伝搬する手間が省ける。
  -` CompositionLocal`を使うことで、任意の場所で`NavController`にアクセスできるため、柔軟性が高い。
- 欠点
  - `CompositionLocal`を多用すると、依存関係が曖昧になり、コードの追跡や理解が難しくなる可能性がある。 
  - テストコードを書く際に`CompositionLocalProvider`を使う必要があり、若干の複雑さが増す。

### 案2: ViewModelを使用する(このリポジトリではこちらを採用)
`ViewModel`を使用して`NavController`の操作を間接的に管理します。
この方法では`ViewModel`が必要なすべてのナビゲーションロジックを保持しComposeの画面は`ViewModel`を通じてナビゲーションを実行します。
- 利点 
  - ViewModelとDI（例えばHilt）を使用することで、依存関係の管理が容易になる。 
  - テストコードが書きやすく、Mockを使用してナビゲーションのテストが可能。 
  - ViewModel内にナビゲーションロジックを集約できるため、コードの可読性とメンテナンス性が向上する。
- 欠点
  - 多少の初期設定とボイラープレートコードが必要になる

## 画面遷移で詰まったこと
`NavigationController`を定義して各コンポーネントの引数で`hiltViewModel()`したら、異なるインスタンスが取得されてしまいました。
`hiltViewModel`関数はViewModelのインスタンスを提供するためのヘルパー関数で、実際には`ViewModelStoreOwner`のスコープに基づいてインスタンスを管理するようです。
で、問題なのがこのスコープが`Composable`単位になりそうだということがわかりました。
`NavigationController`のViewModelはActivityスコープと同一にしたかったため実装は`hiltViewModel(LocalContext.current as ComponentActivity)`としました。
疑問点と検討事項なのですが、`Flutter`ではパフォーマンスの観点から細かくWidgetクラスを分けることが良いとされてきましたが、`DI`でこのようなスコープ管理されるものがいくつかある可能性を考えると、あまり関数に切り出すのもよくないかなと思ってきました。
この点を`GPT-4o`に聞いたのですが、やはり`Compose`でもパフォーマンスと可読性（と再利用）の観点からある程度細かく切り出すという点において同じのようです。
`Hilt`を使う場合は`Composable`な関数の切り出し方もある程度考えて実装する必要があるかなという結論です。まだ2画面しか作っていないのでやっていくうちに`Flutter`と同じような切り出し方で良い、となる可能性もあるかなとは思います。

# 状態管理
ViewModelで`asStateFlow`として定義し、Compose側で`collectAsState`としてデータを受け取れば、そのデータの影響を受けるコンポーネントのみがリビルド対象となるようです。
Flutterのように各コンポーネントを`ConsumerWidget`として定義し、viewModelをwatch（Composeでは`collectAsState`）すると@Previewの使い勝手が悪くなりました。
ChatGPTと話した結果、以下のような設計アプローチを取るのが望ましいと思いました。とりあえず今のところ・・ですが。

## リアクティブなデータソースの分離
UIロジック（特に状態の監視やデータの取得）をViewModelに集約し、`@Composable`関数を純粋にビューのレンダリングに専念させることで、再利用可能でテストしやすいコードを実現します。  
`collectAsState`の使用は、これらのリアクティブなデータが直接影響を与えるコンポーネントに限定することが望ましいです。

## プレビューのシンプル化
末端の`@Composable`関数は、状態を持たない純粋なパラメータ（プリミティブ型やデータクラス）を入力として受け取ります。
これにより、設計時に直接値を渡して簡単にプレビューが可能になり、デザインやレイアウトの調整を迅速に行えます。

## テストの容易さ
ビジネスロジックをViewModelに分離し、UIコンポーネントを純粋なビューとして保持することで、ユニットテストや統合テストが容易になります。
特に、リアクティブなデータの流れがViewModelに集中することで、その挙動を独立してテストでき、エンドツーエンドのテスト時にUIの変更が少ない場合の安定性が向上します。
